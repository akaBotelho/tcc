import os
import socket
import sqlite3
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Dict, List, Optional

import binwalk
import requests
from zapv2 import ZAPv2

from utils import (
    CONFIG_EXTENSIONS,
    CREDENTIAL_EXTENSIONS,
    CREDENTIAL_PATTERNS,
    DB_EXTENSIONS,
    get_credentials_for_vendor,
    load_default_credentials,
    load_env,
    parse_passwd_file,
    parse_shadow_file,
    save_results,
    search_patterns,
    suppress_stderr,
)


class VulnerabilityDetection:
    """Classe para detecção de vulnerabilidades em dispositivos IoT."""

    def __init__(self):
        """Inicializa o detector de vulnerabilidades com configurações do .env."""
        self.env = load_env()
        self.zap_api_key = self.env.get("ZAP_API_KEY", "")
        self.zap_host = self.env.get("ZAP_HOST", "127.0.0.1")
        self.zap_port = self.env.get("ZAP_PORT", 8090)
        self.zap_process = None
        self.zap = None
        self.results = {"zap_scan": [], "firmware_analysis": {}, "brute_force": []}

    def _wait_for_zap(self, timeout: int = 60) -> bool:
        """Aguarda o ZAP iniciar."""
        print(f"[*] Aguardando ZAP em {self.zap_host}:{self.zap_port}")
        start_time = time.time()

        while True:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                sock.connect((self.zap_host, self.zap_port))
                sock.close()
                print("[+] ZAP pronto")
                return True
            except socket.error:
                if time.time() - start_time >= timeout:
                    print("[-] Timeout aguardando ZAP")
                    return False
                time.sleep(2)

    def start_zap(self, daemon: bool = True) -> bool:
        """Inicia o OWASP ZAP."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((self.zap_host, self.zap_port))
            sock.close()

            if result == 0:
                print("[*] ZAP já está rodando")
                self._initialize_zap_client()
                return True
        except Exception:
            pass

        try:
            command = [
                "zaproxy",
                "-port",
                str(self.zap_port),
                "-config",
                f"api.key={self.zap_api_key}",
            ]

            if daemon:
                command.insert(1, "-daemon")

            print(f"[*] Iniciando ZAP")
            self.zap_process = subprocess.Popen(
                command,
                start_new_session=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )

            if not self._wait_for_zap():
                return False

            self._initialize_zap_client()
            return True

        except Exception as e:
            print(f"[-] Erro ao iniciar ZAP: {e}")
            return False

    def _initialize_zap_client(self):
        """Inicializa o cliente da API do ZAP."""
        self.zap = ZAPv2(
            apikey=self.zap_api_key,
            proxies={
                "http": f"http://{self.zap_host}:{self.zap_port}",
                "https": f"http://{self.zap_host}:{self.zap_port}",
            },
        )

    def spider_scan(self, target: str) -> List[str]:
        """Executa spider no alvo."""
        if not self.zap:
            print("[-] ZAP não inicializado")
            return []

        try:
            print(f"[*] Spider em {target}")
            scan_id = self.zap.spider.scan(target)

            while int(self.zap.spider.status(scan_id)) < 100:
                print(f"[*] Spider: {self.zap.spider.status(scan_id)}%")
                time.sleep(2)

            results = self.zap.spider.results(scan_id)
            print(f"[+] {len(results)} URLs descobertas")
            return results

        except Exception as e:
            print(f"[-] Erro no Spider: {e}")
            return []

    def ajax_spider_scan(self, target: str, timeout_minutes: int = 5) -> List[Dict]:
        """Executa Ajax Spider no alvo."""
        if not self.zap:
            print("[-] ZAP não inicializado")
            return []

        try:
            print(f"[*] Ajax Spider em {target}")
            self.zap.ajaxSpider.scan(target)
            timeout = time.time() + (60 * timeout_minutes)

            while self.zap.ajaxSpider.status == "running":
                if time.time() > timeout:
                    print("[!] Ajax Spider timeout")
                    self.zap.ajaxSpider.stop()
                    break
                time.sleep(3)

            results = self.zap.ajaxSpider.results(start=0, count=100)
            print(f"[+] {len(results)} resultados")
            return results

        except Exception as e:
            print(f"[-] Erro no Ajax Spider: {e}")
            return []

    def active_scan(self, target: str, scan_policy: Optional[str] = None) -> List[Dict]:
        """Executa Active Scan no alvo."""
        if not self.zap:
            print("[-] ZAP não inicializado")
            return []

        try:
            print(f"[*] Active Scan em {target}")

            if scan_policy:
                scan_id = self.zap.ascan.scan(target, scanpolicyname=scan_policy)
            else:
                scan_id = self.zap.ascan.scan(target)

            while int(self.zap.ascan.status(scan_id)) < 100:
                print(f"[*] Active Scan: {self.zap.ascan.status(scan_id)}%")
                time.sleep(5)

            alerts = self.zap.core.alerts(baseurl=target)
            print(f"[+] {len(alerts)} alertas")

            # Filtra por confiança (High e Medium)
            high_conf = [a for a in alerts if a.get("confidence") == "High"]
            medium_conf = [a for a in alerts if a.get("confidence") == "Medium"]

            print(f"[!] Confiança HIGH: {len(high_conf)}")
            print(f"[!] Confiança MEDIUM: {len(medium_conf)}")

            self.results["zap_scan"] = alerts
            return alerts

        except Exception as e:
            print(f"[-] Erro no Active Scan: {e}")
            return []

    def full_zap_scan(self, target: str) -> Dict:
        """Executa scan completo (Spider + Ajax Spider + Active Scan)."""
        results = {"spider_urls": [], "ajax_results": [], "vulnerabilities": []}
        results["spider_urls"] = self.spider_scan(target)
        results["ajax_results"] = self.ajax_spider_scan(target)
        results["vulnerabilities"] = self.active_scan(target)
        return results

    def stop_zap(self):
        """Para o ZAP."""
        try:
            if self.zap:
                print("[*] Desligando ZAP")
                self.zap.core.shutdown()

            if self.zap_process:
                self.zap_process.terminate()
                self.zap_process.wait(timeout=10)

            print("[+] ZAP desligado")
        except Exception as e:
            print(f"[-] Erro ao desligar ZAP: {e}")

    def extract_firmware(
        self, firmware_path: str, output_dir: Optional[str] = None
    ) -> Optional[str]:
        """Extrai firmware usando binwalk."""
        print(f"[*] Extraindo firmware: {firmware_path}")

        try:
            with suppress_stderr():
                binwalk.scan(
                    firmware_path,
                    "--run-as=root",
                    signature=True,
                    extract=True,
                    quiet=True,
                    directory=output_dir,
                )

            if output_dir:
                extracted_dirs = list(Path(output_dir).glob("_*extracted*"))
            else:
                extracted_dirs = list(Path(firmware_path).parent.glob("_*extracted*"))

            if extracted_dirs:
                print(f"[+] Extraído em: {extracted_dirs[0]}")
                return str(extracted_dirs[0])

            print("[-] Nenhum diretório extraído")
            return None

        except Exception as e:
            print(f"[-] Erro na extração: {e}")
            return None

    def analyze_firmware(self, extracted_path: str) -> Dict:
        """Analisa firmware extraído buscando informações sensíveis."""
        print(f"[*] Analisando firmware: {extracted_path}")

        results = {
            "users": [],
            "hashes": [],
            "certificates": [],
            "hardcoded_credentials": [],
            "config_files": [],
            "databases": [],
            "db_contents": [],
        }

        path = Path(extracted_path)
        if not path.exists():
            print(f"[-] Diretório não encontrado: {extracted_path}")
            return results

        # Busca /etc/passwd
        for passwd_file in path.rglob("etc/passwd"):
            try:
                content = passwd_file.read_text(errors="ignore")
                users = parse_passwd_file(content)
                results["users"].extend(users)
                print(f"[+] passwd: {len(users)} usuários")
            except Exception:
                continue

        # Busca /etc/shadow
        for shadow_file in path.rglob("etc/shadow"):
            try:
                content = shadow_file.read_text(errors="ignore")
                hashes = parse_shadow_file(content)
                results["hashes"].extend(hashes)
                print(f"[+] shadow: {len(hashes)} hashes")
            except Exception:
                continue

        # Busca certificados e chaves
        for ext in CREDENTIAL_EXTENSIONS:
            for cert_file in path.rglob(f"*{ext}"):
                results["certificates"].append(
                    {
                        "file": str(cert_file),
                        "type": ext,
                        "size": cert_file.stat().st_size,
                    }
                )
        if results["certificates"]:
            print(f"[+] {len(results['certificates'])} certificados/chaves")

        # Busca credenciais hardcoded
        hardcoded = search_patterns(extracted_path, CREDENTIAL_PATTERNS)
        results["hardcoded_credentials"] = hardcoded
        if hardcoded:
            print(f"[+] {len(hardcoded)} arquivos com possíveis credenciais hardcoded")

        # Busca arquivos de configuração
        for ext in CONFIG_EXTENSIONS:
            for config_file in path.rglob(f"*{ext}"):
                results["config_files"].append(
                    {
                        "file": str(config_file),
                        "type": ext,
                        "size": config_file.stat().st_size,
                    }
                )
        if results["config_files"]:
            print(f"[+] {len(results['config_files'])} arquivos de configuração")

        # Busca e extrai bancos de dados
        for ext in DB_EXTENSIONS:
            for db_file in path.rglob(f"*{ext}"):
                db_info = {
                    "file": str(db_file),
                    "type": ext,
                    "size": db_file.stat().st_size,
                }
                results["databases"].append(db_info)

                # Tenta extrair conteúdo do banco
                db_content = self.extract_db_info(str(db_file))
                if db_content:
                    results["db_contents"].append(
                        {
                            "file": str(db_file),
                            "content": db_content,
                        }
                    )

        if results["databases"]:
            print(f"[+] {len(results['databases'])} bancos de dados")

        self.results["firmware_analysis"] = results
        return results

    def extract_db_info(self, db_path: str) -> Optional[Dict]:
        """Extrai informações de arquivo de banco de dados."""
        result = {"tables": [], "data": {}}

        if db_path.endswith(".sql"):
            try:
                content = Path(db_path).read_text(errors="ignore")
                result["raw_sql"] = content[:10000]
                return result
            except Exception:
                return None

        if db_path.endswith((".db", ".sqlite")):
            try:
                with sqlite3.connect(db_path) as conn:
                    cursor = conn.cursor()

                    cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
                    tables = [row[0] for row in cursor.fetchall()]
                    result["tables"] = tables

                    for table in tables:
                        try:
                            cursor.execute(f"SELECT * FROM {table} LIMIT 100")
                            columns = [desc[0] for desc in cursor.description]
                            rows = cursor.fetchall()
                            result["data"][table] = {
                                "columns": columns,
                                "rows": [dict(zip(columns, row)) for row in rows],
                                "total_rows": len(rows),
                            }
                        except Exception:
                            continue

                return result

            except Exception:
                return None

        return None

    def brute_force_auth(
        self,
        target: str,
        service: str,
        users: Optional[List[str]] = None,
        cracked_credentials: Optional[List[Dict]] = None,
        vendor_credentials: Optional[List[str]] = None,
    ) -> List[Dict]:
        """Executa força bruta usando Hydra."""
        print(f"[*] Força bruta em {target} ({service})")

        results = []
        temp_files = []

        if vendor_credentials:
            print(
                f"[*] Testando {len(vendor_credentials)} credenciais padrão do fabricante"
            )
            vendor_results = self._test_vendor_credentials(
                target, service, vendor_credentials
            )
            results.extend(vendor_results)

        if cracked_credentials:
            print(f"[*] Testando {len(cracked_credentials)} credenciais quebradas")
            cracked_results = self._test_cracked_credentials(
                target, service, cracked_credentials
            )
            results.extend(cracked_results)

        wordlist_base = self.env["WORDLIST_PATH"]
        password_list = os.path.join(wordlist_base, self.env["WORDLIST_PASSWORDS"])

        user_file = None
        if users:
            user_file = tempfile.NamedTemporaryFile(
                mode="w", delete=False, suffix=".txt"
            )
            user_file.write("\n".join(users))
            user_file.close()
            temp_files.append(user_file.name)
            user_arg = ["-L", user_file.name]
        else:
            user_list = os.path.join(wordlist_base, self.env["WORDLIST_USERS"])
            user_arg = ["-L", user_list]

        if not os.path.exists(password_list):
            print(f"[-] Wordlist não encontrada: {password_list}")
            self.results["brute_force"] = results
            return results

        output_file = "/tmp/hydra_output.txt"

        try:
            cmd = [
                "hydra",
                *user_arg,
                "-P",
                password_list,
                "-t",
                "4",
                "-f",
                "-o",
                output_file,
                f"{service}://{target}",
            ]

            subprocess.run(cmd, capture_output=True, text=True, timeout=300)

            if os.path.exists(output_file):
                with open(output_file) as f:
                    for line in f:
                        if "login:" in line and "password:" in line:
                            parts = line.strip().split()
                            login_idx = (
                                parts.index("login:") if "login:" in parts else -1
                            )
                            pass_idx = (
                                parts.index("password:") if "password:" in parts else -1
                            )

                            if login_idx > 0 and pass_idx > 0:
                                results.append(
                                    {
                                        "target": target,
                                        "service": service,
                                        "username": parts[login_idx + 1],
                                        "password": parts[pass_idx + 1],
                                    }
                                )
                os.remove(output_file)

        except subprocess.TimeoutExpired:
            print("[-] Timeout no Hydra")
        except FileNotFoundError:
            print("[-] Hydra não instalado")
        except Exception as e:
            print(f"[-] Erro no Hydra: {e}")
        finally:
            for temp_file in temp_files:
                if os.path.exists(temp_file):
                    os.remove(temp_file)

        if results:
            print(f"[+] {len(results)} credenciais encontradas")
        else:
            print("[-] Nenhuma credencial encontrada")

        self.results["brute_force"] = results
        return results

    def _test_cracked_credentials(
        self, target: str, service: str, credentials: List[Dict]
    ) -> List[Dict]:
        """Testa credenciais quebradas usando Hydra com modo -C."""
        results = []
        temp_files = []

        # Cria arquivo no formato user:password para Hydra -C
        cred_file = tempfile.NamedTemporaryFile(mode="w", delete=False, suffix=".txt")
        for cred in credentials:
            cred_file.write(f"{cred['username']}:{cred['password']}\n")
        cred_file.close()
        temp_files.append(cred_file.name)

        output_file = "/tmp/hydra_cracked_output.txt"

        try:
            cmd = [
                "hydra",
                "-C",
                cred_file.name,
                "-t",
                "4",
                "-f",
                "-o",
                output_file,
                f"{service}://{target}",
            ]

            subprocess.run(cmd, capture_output=True, text=True, timeout=60)

            if os.path.exists(output_file):
                with open(output_file) as f:
                    for line in f:
                        if "login:" in line and "password:" in line:
                            parts = line.strip().split()
                            login_idx = (
                                parts.index("login:") if "login:" in parts else -1
                            )
                            pass_idx = (
                                parts.index("password:") if "password:" in parts else -1
                            )

                            if login_idx > 0 and pass_idx > 0:
                                results.append(
                                    {
                                        "target": target,
                                        "service": service,
                                        "username": parts[login_idx + 1],
                                        "password": parts[pass_idx + 1],
                                        "source": "cracked_hash",
                                    }
                                )
                os.remove(output_file)

            if results:
                print(f"[+] {len(results)} credenciais quebradas validadas")

        except subprocess.TimeoutExpired:
            print("[-] Timeout testando credenciais quebradas")
        except Exception as e:
            print(f"[-] Erro testando credenciais quebradas: {e}")
        finally:
            for temp_file in temp_files:
                if os.path.exists(temp_file):
                    os.remove(temp_file)

        return results

    def _test_vendor_credentials(
        self, target: str, service: str, credentials: List[str]
    ) -> List[Dict]:
        """Testa credenciais padrão do fabricante usando Hydra com modo -C."""
        results = []
        temp_files = []

        # Cria arquivo no formato user:password para Hydra -C
        cred_file = tempfile.NamedTemporaryFile(mode="w", delete=False, suffix=".txt")
        for cred in credentials:
            cred_file.write(f"{cred}\n")
        cred_file.close()
        temp_files.append(cred_file.name)

        output_file = "/tmp/hydra_vendor_output.txt"

        try:
            cmd = [
                "hydra",
                "-C",
                cred_file.name,
                "-t",
                "4",
                "-f",
                "-o",
                output_file,
                f"{service}://{target}",
            ]

            subprocess.run(cmd, capture_output=True, text=True, timeout=60)

            if os.path.exists(output_file):
                with open(output_file) as f:
                    for line in f:
                        if "login:" in line and "password:" in line:
                            parts = line.strip().split()
                            login_idx = (
                                parts.index("login:") if "login:" in parts else -1
                            )
                            pass_idx = (
                                parts.index("password:") if "password:" in parts else -1
                            )

                            if login_idx > 0 and pass_idx > 0:
                                results.append(
                                    {
                                        "target": target,
                                        "service": service,
                                        "username": parts[login_idx + 1],
                                        "password": parts[pass_idx + 1],
                                        "source": "default_vendor",
                                    }
                                )
                os.remove(output_file)

            if results:
                print(f"[+] {len(results)} credenciais padrão do fabricante validadas")

        except subprocess.TimeoutExpired:
            print("[-] Timeout testando credenciais do vendor")
        except Exception as e:
            print(f"[-] Erro testando credenciais do vendor: {e}")
        finally:
            for temp_file in temp_files:
                if os.path.exists(temp_file):
                    os.remove(temp_file)

        return results

    def crack_hashes(self, hash_file: str) -> List[Dict]:
        """Tenta quebrar hashes usando John the Ripper."""
        print(f"[*] Quebrando hashes: {hash_file}")

        if not os.path.exists(hash_file):
            print(f"[-] Arquivo não encontrado: {hash_file}")
            return []

        wordlist = os.path.join(
            self.env["WORDLIST_PATH"], self.env["WORDLIST_PASSWORDS"]
        )

        results = []
        try:
            cmd = ["john", f"--wordlist={wordlist}", hash_file]
            subprocess.run(cmd, capture_output=True, text=True, timeout=600)

            show_cmd = ["john", "--show", hash_file]
            proc = subprocess.run(show_cmd, capture_output=True, text=True)

            for line in proc.stdout.split("\n"):
                if ":" in line and not line.startswith("0 password"):
                    parts = line.split(":")
                    if len(parts) >= 2 and parts[1]:
                        results.append(
                            {
                                "username": parts[0],
                                "password": parts[1],
                            }
                        )

            if results:
                print(f"[+] {len(results)} senhas quebradas")
            else:
                print("[-] Nenhuma senha quebrada")

        except subprocess.TimeoutExpired:
            print("[-] Timeout no John")
        except FileNotFoundError:
            print("[-] John não instalado")
        except Exception as e:
            print(f"[-] Erro no John: {e}")

        return results

    def _convert_cpe_to_23(self, cpe: str) -> Optional[str]:
        """Converte CPE do formato 2.2 para 2.3."""
        if not cpe:
            return None

        if cpe.startswith("cpe:2.3:"):
            return cpe

        if cpe.startswith("cpe:/"):
            parts = cpe[5:].split(":")
            if len(parts) >= 3:
                while len(parts) < 11:
                    parts.append("*")
                return "cpe:2.3:" + ":".join(parts)

        return None

    def lookup_cve(
        self, service: str, version: str, cpe_name: Optional[str] = None
    ) -> List[Dict]:
        """Consulta CVEs na API do NVD por keyword ou cpeName."""
        api_key = self.env.get("NVD_API_KEY", "")
        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

        headers = {}
        if api_key:
            headers["apiKey"] = api_key

        results = []

        cpe_23 = self._convert_cpe_to_23(cpe_name)
        if cpe_23:
            print(f"[*] Consultando CVEs por CPE: {cpe_23}")
            params = {"cpeName": cpe_23, "resultsPerPage": 50}
            cve_results = self._fetch_cves(base_url, params, headers)
            results.extend(cve_results)

        print(f"[*] Consultando CVEs por keyword: {service} {version}")
        params = {"keywordSearch": f"{service} {version}", "resultsPerPage": 20}
        keyword_results = self._fetch_cves(base_url, params, headers)

        existing_ids = {r["cve_id"] for r in results}
        for cve in keyword_results:
            if cve["cve_id"] not in existing_ids:
                results.append(cve)

        if results:
            print(f"[+] {len(results)} CVEs encontrados")
            critical = [
                r for r in results if r.get("cvss_score") and r["cvss_score"] >= 9.0
            ]
            if critical:
                print(f"[!] {len(critical)} CVEs críticos (CVSS >= 9.0)")
        else:
            print("[-] Nenhum CVE encontrado")

        return results

    def _fetch_cves(self, base_url: str, params: Dict, headers: Dict) -> List[Dict]:
        """Busca CVEs na API do NVD."""
        results = []
        try:
            response = requests.get(
                base_url, params=params, headers=headers, timeout=30
            )
            response.raise_for_status()
            data = response.json()

            for vuln in data.get("vulnerabilities", []):
                cve = vuln.get("cve", {})
                cve_id = cve.get("id", "")

                descriptions = cve.get("descriptions", [])
                description = next(
                    (d["value"] for d in descriptions if d.get("lang") == "en"),
                    "Sem descrição",
                )

                metrics = cve.get("metrics", {})
                cvss_score = None
                cvss_severity = None

                for cvss_version in ["cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]:
                    if cvss_version in metrics and metrics[cvss_version]:
                        cvss_data = metrics[cvss_version][0].get("cvssData", {})
                        cvss_score = cvss_data.get("baseScore")
                        cvss_severity = cvss_data.get(
                            "baseSeverity", metrics[cvss_version][0].get("baseSeverity")
                        )
                        break

                results.append(
                    {
                        "cve_id": cve_id,
                        "description": description[:500],
                        "cvss_score": cvss_score,
                        "cvss_severity": cvss_severity,
                        "published": cve.get("published", ""),
                    }
                )

        except requests.exceptions.Timeout:
            print("[-] Timeout na consulta NVD")
        except requests.exceptions.RequestException as e:
            print(f"[-] Erro na consulta NVD: {e}")
        except Exception as e:
            print(f"[-] Erro: {e}")

        return results

    def _get_web_url(self, target: str, web_service: Dict) -> str:
        """Obtém URL da interface web do alvo."""
        port = web_service.get("port", 80)
        protocol = web_service.get("protocol", "http")

        if port in [80, 443]:
            return f"{protocol}://{target}"
        return f"{protocol}://{target}:{port}"

    def _get_firmware_path(
        self, firmware_path: Optional[str], http_objects: List[Dict]
    ) -> Optional[str]:
        """Obtém caminho do firmware (parâmetro, tráfego ou .env)."""

        if firmware_path and os.path.exists(firmware_path):
            print(f"[+] Firmware fornecido: {firmware_path}")
            return firmware_path

        for obj in http_objects:
            if obj.get("type") == "firmware":
                path = obj.get("path")
                if path and os.path.exists(path):
                    print(f"[+] Firmware detectado no tráfego: {path}")
                    return path

        env_firmware = self.env.get("FIRMWARE_PATH", "")
        if env_firmware and os.path.exists(env_firmware):
            print(f"[+] Firmware configurado no .env: {env_firmware}")
            return env_firmware

        print("[*] Nenhum firmware encontrado, pulando análise de firmware")
        return None

    def analyze(
        self,
        target: str,
        scan_results: Dict,
        output_dir: str,
        firmware_path: Optional[str] = None,
        http_objects: Optional[List[Dict]] = None,
    ) -> Dict:
        """Executa análise completa de vulnerabilidades."""
        print(f"\n[*] Iniciando análise de vulnerabilidades em {target}")

        all_results = {
            "target": target,
            "web_scan": None,
            "firmware_analysis": None,
            "brute_force": [],
            "cve_lookup": [],
        }

        vendor = scan_results.get("vendor", "")
        wordlist_base = self.env["WORDLIST_PATH"]
        default_creds_csv = os.path.join(
            wordlist_base, self.env["WORDLIST_DEFAULT_CREDS"]
        )
        credentials_by_vendor = load_default_credentials(default_creds_csv)
        vendor_credentials = get_credentials_for_vendor(credentials_by_vendor, vendor)

        if scan_results.get("has_web_interface") and scan_results.get("web_services"):
            web_service = scan_results["web_services"][0]
            web_url = self._get_web_url(target, web_service)
            print(f"[+] Interface web detectada: {web_url}")

            if self.start_zap():
                all_results["web_scan"] = self.full_zap_scan(web_url)
                save_results(output_dir, "03", "zap_scan", all_results["web_scan"])
                self.stop_zap()
        else:
            print("[*] Nenhuma interface web detectada, pulando ZAP")

        resolved_firmware = self._get_firmware_path(firmware_path, http_objects or [])
        if resolved_firmware:
            extracted = self.extract_firmware(resolved_firmware, output_dir)
            if extracted:
                all_results["firmware_analysis"] = self.analyze_firmware(extracted)
                save_results(
                    output_dir,
                    "04",
                    "firmware_analysis",
                    all_results["firmware_analysis"],
                )

                if all_results["firmware_analysis"].get("hashes"):
                    hash_file = os.path.join(output_dir, "shadow_hashes.txt")
                    with open(hash_file, "w") as f:
                        for h in all_results["firmware_analysis"]["hashes"]:
                            f.write(f"{h['username']}:{h['hash']}\n")

                    cracked = self.crack_hashes(hash_file)
                    if cracked:
                        all_results["firmware_analysis"]["cracked_passwords"] = cracked
                        save_results(output_dir, "05", "cracked_hashes", cracked)

        cracked = all_results.get("firmware_analysis", {}).get("cracked_passwords", [])
        for svc in scan_results.get("brute_force_services", []):
            print(f"[*] Testando força bruta em {svc['service']}")
            bf_results = self.brute_force_auth(
                target,
                svc["service"],
                cracked_credentials=cracked,
                vendor_credentials=vendor_credentials,
            )
            if bf_results:
                all_results["brute_force"].extend(bf_results)

        if all_results["brute_force"]:
            save_results(output_dir, "06", "brute_force", all_results["brute_force"])

        for host in scan_results.get("hosts", []):
            for port_info in host.get("ports", []):
                service = port_info.get("service", "")
                product = port_info.get("product", "")
                version = port_info.get("version", "")
                cpe = port_info.get("cpe", "")

                search_term = product if product else service
                if search_term and version:
                    cves = self.lookup_cve(
                        search_term, version, cpe_name=cpe if cpe else None
                    )
                    if cves:
                        all_results["cve_lookup"].append(
                            {
                                "service": service,
                                "product": product,
                                "version": version,
                                "cpe": cpe,
                                "cves": cves,
                            }
                        )

        if all_results["cve_lookup"]:
            save_results(output_dir, "07", "cve_lookup", all_results["cve_lookup"])

        save_results(output_dir, "08", "vulnerability_analysis", all_results)

        print(f"\n[+] Análise concluída. Resultados em: {output_dir}/")
        return all_results


def main():
    from information_gathering import InformationGathering

    target_ip = "192.168.0.111"
    ig = InformationGathering(target_ip)
    scan_results = ig.nmap_scan()

    vd = VulnerabilityDetection()
    output_dir = os.path.join(vd.env["OUTPUT_DIR"], target_ip)

    vd.analyze(
        target_ip,
        scan_results,
        output_dir,
        "../IoTGoat-raspberry-pi2.img",
    )


if __name__ == "__main__":
    main()
